# CS 02
This report outlines the tasks for setting up build automation using Gradle as part of a two-part assignment.
The first part focuses on automating essential tasks such as executing the server, testing, and creating backups.
The second part covers converting a Maven-based REST service project to Gradle, building custom tasks, and handling integration testing.
Additionally, this report discusses an alternative build automation tool - Apache Ant - and compares its features with Gradle.

## Part 1
###  Gradle Task to Execute the Server
To run the server using Gradle, a custom task was created in the build.gradle file. This task will depend on the application plugin to simplify the running of Java applications.
First it was checked that the application plugin was applied and that the **mainClassName** was defined.
```
plugins {
    id 'application'
}
```
```
application{
    mainClass = 'basic_demo.App'
}
```
Then the task to execute the server was added
```
task runServer(type:JavaExec, dependsOn: classes){
    group = "DevOps"
    description = "Launches a chat server to which the clients will connect"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'basic_demo.ChatServerApp'
    args '59001'
}
```
### Adding a Unit Test and Configuring Gradle
Gradle supports unit testing via the JUnit library. To do it, the following dependencies were added
```
dependencies {
    ...(others that already existed)

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
}
```
Then the class **ChatServerAppTest.java** was created and a unit test added
```
package basic_demo;

import org.junit.Test;

import static org.junit.Assert.assertNotNull;

public class ChatServerAppTest {

    @Test
    public void testChatServerAppNotNull() {
        ChatServerApp chatServerApp = new ChatServerApp();
        assertNotNull(chatServerApp);
    }
}
```
Then the test was executed with the default test task:
```
./gradlew test
```
### Backup Task using Copy Type
A backup task that copies the contents of the src folder to a backup folder was created and added to build.gradle.
```
task createBackup(type: Copy) {
    from 'src'
    into 'backup'
}
```
This task copies everything from the src folder into a new backup folder in the project directory.
### Archiving the Backup using Zip Task
To create a Zip file of the backup, a task of type Zip that depends on the **createBackup** task was created and added to build.gradle.
```
task createZipBackup(type: Zip, dependsOn: createBackup) {
    from 'backup'
    archiveFileName = 'backup.zip'
    destinationDirectory = file('backup')
}
```
This archives the contents of the backup folder into a file named **backup.zip**
### Explanation of Gradle and JDK Toolchain
Gradle comes with a built-in ability to manage the Java Development Kit (JDK) and toolchain.
By default, Gradle uses the **javaToolchains** mechanism to automatically locate the JDK.

When running the command **gradle -q javaToolchain**, Gradle will provide details about the Java toolchain it is using.
This feature eliminates the need to manually install or configure specific versions of the JDK.

## Part 2
The first tasks that was asked us to do to create a custom task tha zips the entire source code our project and stores it in a backup directory, and the task that we were able to achieve:
````
task createZipBackup(type: Zip) {
    from 'src'
    archiveFileName = 'backup.zip'
    destinationDirectory = file('backup')
}
````
We first define that the task is Zip type. Then we define where it will retrieve the files to zip, in the from section, the name of the archive that will be created and then were the destination directory will be.


The second custom task that was required was one that depended on the installDist task and runs the application using the generated distribution scripts. We were also told to verify wich executable script we were supposed to run based on the operating system.
````
task runsAppPerOS(dependsOn: installDist) {
    doLast {
        def os = org.gradle.internal.os.OperatingSystem.current()
        def installDir = "build/install/app"

        if (os.isWindows()) {
            exec {
                commandLine "$installDir/bin/app.bat"
            }
        } else {
            exec {
                commandLine "$installDir/bin/app"
            }
        }
    }
}
````
What this task does is it runs the installed application using the appropriate executable, wich it verifies with the  org.gradle.internal.os.OperatingSystem.current(), that verifies the current operating system.

For the third custom task:
````
task generateJavadoc(type: Zip, dependsOn: javadoc) {
    from javadoc.destinationDir
    archiveFileName = 'javadoc.zip'
    destinationDirectory = file("build/javadoc")
}
````
The generateJavadoc task packages the Javadoc documentation (generated by the javadoc task) into a zip file named javadoc.zip and saves it in the build/javadoc directory.


Then we created a task to run the integration test:

````
sourceSets {
    integrationTest {
        java {
            srcDir 'src/main/test/integrationTest/java'
        }
        resources {
            srcDir 'src/main/test/integrationTest/resources'
        }
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}


task integrationTest(type: Test) {
    description = 'Runs the integration tests.'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test
}
check.dependsOn integrationTest


````

The integrationTest task is responsible for running integration tests after the unit tests (test task). It uses the test classes and runtime classpath from the integrationTest source set. The check task is also configured to depend on the completion of integrationTest, ensuring that both unit and integration tests are run when performing verification.

## Alternative Solution - Apache Ant
**Apache Ant** (Another Neat Tool) is a build tool that was initially developed to automate software build processes, particularly for Java projects. 
It operates based on a series of XML-based instructions that define tasks such as compiling code, running tests, packaging applications into JAR or WAR files, and more.

### How Ant Compares to Gradle
		
| Feature    | Apache Ant | Gradle |
| -------- | ------- | ------- |
| Build Language  | XML-based    | Groovy/Kotlin DSL |
| Build Configuration | Manual, flexible     | Declarative with script flexibility |
| Dependency Management    | Needs manual configuration (with Ivy)	|Integrated via repositories and dependencies     |
| Ease of Use  | Less user-friendly due to XML verbosity |	Easier, more modern syntax     |
| Performance | Moderate (no incremental build support)	| High performance with incremental builds       |
| Plugins    | Fewer built-in plugins, but flexible	| Large plugin ecosystem      |
| Default Tasks  | Few built-in tasks, needs manual setup	| Lots of built-in tasks for Java projects     |
| Incremental Builds	 | No     | Yes, optimized for incremental builds |

### Strengths and Limitations of Apache Ant
#### Strengths:
- **Highly flexible:** Ant is designed to be very flexible. It provides a broad set of built-in tasks (e.g., javac, jar, copy, mkdir), and you can define custom tasks easily.
- **Task-based execution:** Each step in the build process is defined as a separate task, allowing for highly customized builds.
- **Good for small projects:** Ant is well-suited for small projects or projects with simple build requirements.
- **No conventions:** Ant doesn’t impose a rigid structure. This gives developers freedom in organizing their projects.
-**Widely used:** Ant has been around since 2000 and has been used in many enterprise Java projects.
  
#### Limitations:
- **No built-in dependency management:** Ant doesn’t have built-in support for dependency management like Gradle. However, this can be addressed by integrating Apache Ivy, a dependency management system often used with Ant.
- **Verbosity:** The XML syntax used in Ant can make builds more verbose and harder to manage as the project grows. It's less intuitive than Gradle’s Groovy or Kotlin DSL.
- **No incremental build support:** Ant does not support incremental builds out of the box, meaning it will rebuild everything every time you run a build, which can slow down build times for large projects.
- **Fewer built-in features:** Compared to Gradle, Ant has fewer built-in features and plugins, meaning that for complex tasks, developers will need to write a lot of custom code.

### Implementation
#### Set-up
The following library - Apache Ivy - was used to assist with the dependency management. All this is implemented on the **build.xml**
```
    <target name="install-ivy" unless="ivy.installed">
        <mkdir dir="${user.home}/.ant/lib"/>
        <get dest="${user.home}/.ant/lib/ivy.jar" src="http://search.maven.org/remotecontent?filepath=org/apache/ivy/ivy/2.4.0/ivy-2.4.0.jar"/>
        <fail message="Ivy has been installed. Run the build again"/>
    </target>
    <available classname="org.apache.ivy.Main" property="ivy.installed"/>
    <target name="resolve" depends="install-ivy">
        <ivy:retrieve pattern="${lib.dir}/[artifact]-[revision](-[classifier]).[ext]">
            <dependency org="org.springframework.boot" name="spring-boot-starter-web" rev="3.2.5" conf="default"/>
            <dependency org="org.springframework.boot" name="spring-boot-starter-data-jpa" rev="3.2.5" conf="default"/>
            <dependency org="org.springframework.boot" name="spring-boot-starter-hateoas" rev="3.2.5" conf="default"/>
        </ivy:retrieve>
    </target>
```
#### Tasks to Execute the Server
The following tasks were defined to execute the server
```
    <target name="init">
        <mkdir dir="${build.dir}"/>
        <mkdir dir="${classes.dir}"/>
        <mkdir dir="${backup.dir}"/>
    </target>
    <target name="compile" depends="init">
        <javac srcdir="${src.dir}" destdir="${classes.dir}" classpathref="project.classpath"/>
    </target>
    <target name="package" depends="compile">
        <mkdir dir="${build.dir}/lib"/>
        <jar destfile="${build.dir}/lib/${ant.project.name}.jar" basedir="${classes.dir}">
            <manifest>
                <attribute name="Main-Class" value="${mainClass}"/>
            </manifest>
        </jar>
    </target>
    <target name="runApp" depends="package">
        <condition property="is.windows">
            <os family="windows"/>
        </condition>
        <condition property="is.unix">
            <os family="unix"/>
        </condition>
        <exec executable="java" failonerror="true">
            <arg path="build/lib/tut-rest-ant.jar"/>
        </exec>
    </target>
    <target name="run" depends="compile, runApp"/>
```

#### Task to Make a Zip Backup of the Sources
The following tasks were defined to make a zip backup of the sources
```
    <target name="createZipBackup">
        <copy todir="${backup.dir}">
            <fileset dir="src"/>
        </copy>
        <zip destfile="${backup.dir}/backup.zip" basedir="${backup.dir}"/>
    </target>
```

#### Task for Generating Javadoc
The following tasks were defined to generate and make a zip of the javadoc. 
Ant provides the built-in **javadoc** task, which allows generating Javadoc documentation for the project.
```
    <target name="prepare-javadoc">
        <mkdir dir="${javadoc.dir}"/>
        <mkdir dir="${javadoc.zip.dir}"/>
    </target>
    <target name="javadoc" depends="prepare-javadoc">
        <javadoc destdir="${javadoc.dir}" sourcepath="src/main/java">
            <classpath>
                <fileset dir="${build.dir}/lib" includes="*.jar"/>
            </classpath>
            <source>17</source>
        </javadoc>
    </target>
    <target name="generateJavadocZip" depends="javadoc">
        <zip destfile="${javadoc.zip.dir}/javadoc.zip">
            <fileset dir="${javadoc.dir}"/>
        </zip>
    </target>
```
#### Task for Integration Tests 
The following tasks was defined for Ant  to handle integration tests
```
     <target name="integrationTest" >
        <mkdir dir="${integration.test.dir}"/>
        <java fork="true" failonerror="true">
            <classpath>
                <pathelement path="${build.dir}/classes"/>
                <pathelement path="${build.dir}/lib/*"/>
            </classpath>
            <jvmarg value="-Dtest.dir=${integration.test.dir}"/>
            <arg value="EmployeeIntegrationTest"/>
        </java>
    </target>
```
### Conclusion of Apache Ant
In conclusion, **Apache Ant** is a valid alternative to Gradle, particularly for small to medium-sized projects where flexibility is crucial. 
However, for modern, larger-scale projects with complex dependency management needs, Gradle would typically be a more suitable choice due to its built-in features for dependency handling and incremental builds.
