# CS 02
This report outlines the tasks for setting up build automation using Gradle as part of a two-part assignment.
The first part focuses on automating essential tasks such as executing the server, testing, and creating backups.
The second part covers converting a Maven-based REST service project to Gradle, building custom tasks, and handling integration testing.
Additionally, this report discusses an alternative build automation tool and compares its features with Gradle.

## Part 1
###  Gradle Task to Execute the Server
To run the server using Gradle, a custom task was created in the build.gradle file. This task will depend on the application plugin to simplify the running of Java applications.
First it was checked that the application plugin was applied and that the **mainClassName** was defined.
```
plugins {
    id 'application'
}
```
```
application{
    mainClass = 'basic_demo.App'
}
```
Then the task to execute the server was added
```
task runServer(type:JavaExec, dependsOn: classes){
    group = "DevOps"
    description = "Launches a chat server to which the clients will connect"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'basic_demo.ChatServerApp'
    args '59001'
}
```
### Adding a Unit Test and Configuring Gradle
Gradle supports unit testing via the JUnit library. To do it, the following dependencies were added
```
dependencies {
    ...(others that already existed)

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
}
```
Then the class **ChatServerAppTest.java** was created and a unit test added
```
package basic_demo;

import org.junit.Test;

import static org.junit.Assert.assertNotNull;

public class ChatServerAppTest {

    @Test
    public void testChatServerAppNotNull() {
        ChatServerApp chatServerApp = new ChatServerApp();
        assertNotNull(chatServerApp);
    }
}
```
Then the test was executed with the default test task:
```
./gradlew test
```
### Backup Task using Copy Type
A backup task that copies the contents of the src folder to a backup folder was created and added to build.gradle.
```
task createBackup(type: Copy) {
    from 'src'
    into 'backup'
}
```
This task copies everything from the src folder into a new backup folder in the project directory.
### Archiving the Backup using Zip Task
To create a Zip file of the backup, a task of type Zip that depends on the **createBackup** task was created and added to build.gradle.
```
task createZipBackup(type: Zip, dependsOn: createBackup) {
    from 'backup'
    archiveFileName = 'backup.zip'
    destinationDirectory = file('backup')
}
```
This archives the contents of the backup folder into a file named **backup.zip**
### Explanation of Gradle and JDK Toolchain
Gradle comes with a built-in ability to manage the Java Development Kit (JDK) and toolchain.
By default, Gradle uses the **javaToolchains** mechanism to automatically locate the JDK.

When running the command **gradle -q javaToolchain**, Gradle will provide details about the Java toolchain it is using.
This feature eliminates the need to manually install or configure specific versions of the JDK.

## Part 2
The first tasks that was asked us to do to create a custom task tha zips the entire source code our project and stores it in a backup directory, and the task that we were able to achieve:
````
task createZipBackup(type: Zip) {
    from 'src'
    archiveFileName = 'backup.zip'
    destinationDirectory = file('backup')
}
````
We first define that the task is Zip type. Then we define where it will retrieve the files to zip, in the from section, the name of the archive that will be created and then were the destination directory will be.


The second custom task that was required was one that depended on the installDist task and runs the application using the generated distribution scripts. We were also told to verify wich executable script we were supposed to run based on the operating system.
````
task runsAppPerOS(dependsOn: installDist) {
    doLast {
        def os = org.gradle.internal.os.OperatingSystem.current()
        def installDir = "build/install/app"

        if (os.isWindows()) {
            exec {
                commandLine "$installDir/bin/app.bat"
            }
        } else {
            exec {
                commandLine "$installDir/bin/app"
            }
        }
    }
}
````
What this task does is it runs the installed application using the appropriate executable, wich it verifies with the  org.gradle.internal.os.OperatingSystem.current(), that verifies the current operating system.

For the third custom task:
````
task generateJavadoc(type: Zip, dependsOn: javadoc) {
    from javadoc.destinationDir
    archiveFileName = 'javadoc.zip'
    destinationDirectory = file("build/javadoc")
}
````
The generateJavadoc task packages the Javadoc documentation (generated by the javadoc task) into a zip file named javadoc.zip and saves it in the build/javadoc directory.


Then we created a tasnk to run the integration test:

````
sourceSets {
    integrationTest {
        java {
            srcDir 'src/main/test/integrationTest/java'
        }
        resources {
            srcDir 'src/main/test/integrationTest/resources'
        }
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}


task integrationTest(type: Test) {
    description = 'Runs the integration tests.'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test
}
check.dependsOn integrationTest


````

The integrationTest task is responsible for running integration tests after the unit tests (test task). It uses the test classes and runtime classpath from the integrationTest source set. The check task is also configured to depend on the completion of integrationTest, ensuring that both unit and integration tests are run when performing verification.
